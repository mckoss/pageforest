<html>
<head>
<title>Vector Utilities Test Page</title>
<script src="/.static/js/namespace.js"></script>
<script src="/.static/js/base.js"></script>
<script src="/.static/js/timer.js"></script>
<script src="/.static/js/unit.js"></script>
<script src="/.static/js/vector.js"></script>
</head>
<body>
<h1><script>document.write(document.title);</script></h1>
<script>
var unit = global_namespace.import('org.startpad.unit');
var ts = new unit.TestSuite();
ts.DWOutputDiv();

var vector = global_namespace.import('org.startpad.vector');

ts.AddTest("Copy", function(ut) {
    a = [1,2,3]
    b = vector.copy(a);
    ut.Assert(vector.equal(a,b));
    ut.Assert(a !== b);

    c = vector.append(a,b,[7,8,9]);
    ut.Assert(vector.equal(c, [1,2,3,1,2,3,7,8,9]));
    ut.Assert(vector.equal(vector.subFrom([2,2], [1,1]), [1,1]));
});

ts.AddTest("Vector functions", function(ut)
{
    var V = vector;

    var vOrig = [1,2,3];
    var v = V.copy(vOrig);
    ut.AssertEq(v, [1,2,3]);
    ut.Assert(v !== vOrig, "copy must be distinct");
    vOrig[0] = 4;
    ut.AssertEq(v, [1,2,3]);

    vOrig = [1,[2,3], 4];
    v = V.copy(vOrig);
    ut.Assert(V.equal(v, [1,[2,3],4]));
    vOrig[1][0] = 5;
    ut.Assert(V.equal(v, [1, [5,3],4]), "only shallow copy");

    var v1 = [2,5];
    var v2 = [1, 2];
    v = V.add(v1, v2);
    ut.Assert(V.equal(v, [3,7]));
    ut.AssertEq(v1, [2,5], "unmodified args");
    ut.AssertEq(v2, [1,2], "unmodified args");
    v = V.add(v1, v1, v1, v1);
    ut.AssertEq(v, [8, 20]);

    v = V.sub(v1, v2);
    ut.AssertEq(v, [1, 3]);

    // Vector multiply
    v = V.mult(v1, v2);
    ut.AssertEq(v, [2, 10]);

    // Scalar multiply
    v = V.mult(v1, 2);
    ut.AssertEq(v, [4, 10]);

    v = V.mult(2, v1);
    ut.AssertEq(v, [4, 10]);

    v = V.mult(1,2,3);
    ut.AssertEq(v, 6);

    // Mixed multiply
    v = V.mult(v1, 2, v2);
    ut.AssertEq(v, [4,20]);

    // Unequal arrays throws
    ut.AssertThrows("Mismatched Vector Size", function(ut)
        {
        v = V.mult([1,2,3], [1,2]);
        });

    ut.AssertEq(V.floor([1,1.2, -0.5]), [1, 1, -1]);
    ut.AssertEq(V.dotProduct(v1, v2), 12);

    v = V.addTo(v1, v2);
    ut.AssertIdent(v, v1);
    ut.AssertEq(v1, [3, 7]);

    v = V.subFrom(v1, v2);
    ut.AssertIdent(v, v1);
    ut.AssertEq(v1, [2, 5]);

    ut.AssertEq(V.max([0, 5], [-1, 10]), [0, 10]);
});

ts.AddTest("Point and Rect Functions", function(ut)
{
    var V = vector;

    var rc = [10, 10, 100, 100];

    ut.AssertEq(V.ul(rc), [10, 10]);
    ut.AssertEq(V.lr(rc), [100, 100]);
    ut.AssertEq(V.size(rc), [90, 90]);

    ut.AssertEq(V.ptCenter(rc), [55, 55]);
    ut.AssertEq(V.ptCenter(rc, 0), [10, 10]);
    ut.AssertEq(V.ptCenter(rc, 1), [100, 100]);
    ut.AssertEq(V.ptCenter(rc, 0.2), [28, 28]);
    ut.AssertEq(rc, [10, 10, 100, 100]);

    ut.AssertEq(V.ptCenter(rc, [0.5, 0.2]), [55, 28]);

    ut.AssertEq(V.boundingBox([0, 1], [1,0]), [0, 0, 1, 1]);
    ut.AssertEq(V.boundingBox([0,0,1,1], [2,2,4,4]), [0,0,4,4]);
});

ts.Run();
ts.Report();

</script>
</body>
</html>
